---
import { getCollection } from 'astro:content';
import ArticleLayout from '../../layouts/ArticleLayout.astro';
import PrevNext from '../../components/PrevNext.astro';
import EditOnGitHub from '../../components/EditOnGitHub.astro';
import { calculateReadingTime } from '../../utils/reading-time';
import { getLastModified, formatRelativeTime } from '../../utils/last-modified';

export async function getStaticPaths() {
  const notes = await getCollection('notes', ({ data }) => {
    return !data.draft;
  });
  
  // Sort notes by date descending (newest first)
  const sortedNotes = notes.sort((a, b) => 
    b.data.date.valueOf() - a.data.date.valueOf()
  );
  
  return sortedNotes.map((note, index) => {
    // Previous = newer (index - 1), Next = older (index + 1)
    const prev = index > 0 ? sortedNotes[index - 1] : null;
    const next = index < sortedNotes.length - 1 ? sortedNotes[index + 1] : null;
    
    return {
      params: { slug: note.slug },
      props: {
        note,
        prev: prev ? {
          slug: prev.slug,
          title: prev.data.title,
          description: prev.data.description
        } : undefined,
        next: next ? {
          slug: next.slug,
          title: next.data.title,
          description: next.data.description
        } : undefined
      },
    };
  });
}

const { note, prev, next } = Astro.props;
const { Content, headings } = await note.render();
const readingTime = calculateReadingTime(note.body);
const formattedDate = note.data.date.toLocaleDateString('en-US', {
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});

const base = import.meta.env.BASE_URL || '/';
const baseWithSlash = base.endsWith('/') ? base : `${base}/`;
const breadcrumbItems = [
  { label: 'Notes', href: `${baseWithSlash}notes/` },
  { label: note.data.title }
];

// Construct GitHub file path for edit link
const githubFilePath = `src/content/notes/${note.id}`;

// Get last modified date from git
const lastModifiedDate = getLastModified(`src/content/notes/${note.id}`);
const lastModifiedRelative = formatRelativeTime(lastModifiedDate);
const showLastModified = lastModifiedDate.getTime() !== note.data.date.getTime();
---

<ArticleLayout
  title={`${note.data.title} - Notes`}
  description={note.data.description || `A note from ${formattedDate}`}
  publishedTime={note.data.date}
  modifiedTime={lastModifiedDate}
  tags={note.data.tags}
  headings={headings}
  breadcrumbItems={breadcrumbItems}
>
  <article class="prose dark:prose-invert max-w-none">
    <header class="mb-8">
      <h1>{note.data.title}</h1>
      <div class="flex flex-wrap items-center gap-4 text-sm text-gray-600 dark:text-gray-400">
        <time datetime={note.data.date.toISOString()}>{formattedDate}</time>
        {showLastModified && (
          <span class="flex items-center gap-1" title={`Last modified: ${lastModifiedDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}`}>
            <span class="material-symbols-outlined text-[16px]">update</span>
            Updated {lastModifiedRelative}
          </span>
        )}
        <span class="flex items-center gap-1">
          <span class="material-symbols-outlined text-[16px]">schedule</span>
          {readingTime}
        </span>
        {note.data.tags && note.data.tags.length > 0 && (
          <span class="flex flex-wrap gap-2">
            {note.data.tags.map(tag => (
              <span class="inline-block bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded">
                {tag}
              </span>
            ))}
          </span>
        )}
        <div class="ml-auto">
          <EditOnGitHub filePath={githubFilePath} />
        </div>
      </div>
    </header>
    <Content />
  </article>
  <PrevNext prev={prev} next={next} collection="notes" />
</ArticleLayout>
